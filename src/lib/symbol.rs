pub enum Keyword {
  Break,
  Case,
  Catch,
  Class,
  Const,
  Continue,
  Default,
  Delete,
  Do,
  Else,
  Enum,
  Export,
  Extends,
  Finally,
  For,
  Function,
  If,
  Import,
  In,
  Instanceof,
  Let,
  New,
  Return,
  Super,
  Switch,
  This,
  Throw,
  Try,
  Typeof,
  Var,
  Void,
  While,
  With
}

pub fn value_of_keyword(key: Keyword) -> &'static str {
  match key {
    Keyword::Break => "break",
    Keyword::Case => "case",
    Keyword::Catch => "catch",
    Keyword::Class => "class",
    Keyword::Const => "const",
    Keyword::Continue => "continue",
    Keyword::Default => "default",
    Keyword::Delete => "delete",
    Keyword::Do => "do",
    Keyword::Else => "else",
    Keyword::Enum => "enum",
    Keyword::Export => "export",
    Keyword::Extends => "extends",
    Keyword::Finally => "finally",
    Keyword::For => "for",
    Keyword::Function => "function",
    Keyword::If => "if",
    Keyword::Import => "import",
    Keyword::In => "in",
    Keyword::Instanceof => "instanceof",
    Keyword::Let => "let",
    Keyword::New => "new",
    Keyword::Return => "return",
    Keyword::Super => "super",
    Keyword::Switch => "switch",
    Keyword::This => "this",
    Keyword::Throw => "throw",
    Keyword::Try => "try",
    Keyword::Typeof => "typeof",
    Keyword::Var => "var",
    Keyword::Void => "void",
    Keyword::While => "while",
    Keyword::With => "with",
  }
}

pub enum Denotation {
  BraceL,
  BraceR,
  ParenL,
  ParenR,
  BracketL,
  BracketR,
  Dot,
  Semi,
  Comma,
  LT,
  GT,
  LE,
  GE,
  Eq,
  NotEq,
  EqStrict,
  NotEqStrict,
  Add,
  Sub,
  Mul,
  Div,
  Mod,
  Inc,
  Dec,
  SHL,
  SAR,
  SHR,
  BitAnd,
  BitOr,
  BitXor,
  Not,
  BitNot,
  And,
  Or,
  Conditional,
  Colon,
  Assign,
  AssignAdd,
  AssignSub,
  AssignMul,
  AssignDiv,
  AssignMod,
  AssignSHL,
  AssignSAR,
  AssignSHR,
  AssignBitAnd,
  AssignBitOr,
  AssignBitXor,
}

pub fn value_of_annotation(denotation: Denotation) -> &'static str {
  match denotation {
    Denotation::BraceL => "{",
    Denotation::BraceR => "}",
    Denotation::ParenL => "(",
    Denotation::ParenR => ")",
    Denotation::BracketL => "[",
    Denotation::BracketR => "]",
    Denotation::Dot => ".",
    Denotation::Semi => ";",
    Denotation::Comma => ",",
    Denotation::LT => "<",
    Denotation::GT => ">",
    Denotation::LE => "<=",
    Denotation::GE => ">=",
    Denotation::Eq => "==",
    Denotation::NotEq => "!=",
    Denotation::EqStrict => "===",
    Denotation::NotEqStrict => "!==",
    Denotation::Add => "+",
    Denotation::Sub => "-",
    Denotation::Mul => "*",
    Denotation::Div => "/",
    Denotation::Mod => "%",
    Denotation::Inc => "++",
    Denotation::Dec => "--",
    Denotation::SHL => "<<",
    Denotation::SAR => ">>",
    Denotation::SHR => ">>>",
    Denotation::BitAnd => "&",
    Denotation::BitOr => "|",
    Denotation::BitXor => "^",
    Denotation::Not => "!",
    Denotation::BitNot => "~",
    Denotation::And => "&&",
    Denotation::Or => "||",
    Denotation::Conditional => "?",
    Denotation::Colon => ":",
    Denotation::Assign => "=",
    Denotation::AssignAdd => "+=",
    Denotation::AssignSub => "-=",
    Denotation::AssignMul => "*=",
    Denotation::AssignDiv => "/=",
    Denotation::AssignMod => "%=",
    Denotation::AssignSHL => "<<=",
    Denotation::AssignSAR => ">>=",
    Denotation::AssignSHR => ">>>=",
    Denotation::AssignBitAnd => "&=",
    Denotation::AssignBitOr => "|=",
    Denotation::AssignBitXor => "^=",
  }
}